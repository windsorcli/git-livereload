#!/usr/bin/env bash
set -ou pipefail
trap 'catch $? $LINENO' EXIT

catch() {
  if [ "$1" != "0" ]; then
    echo "Error $1 occurred on $2"
  fi
}

RSYNC_EXCLUDE=${RSYNC_EXCLUDE:-}
RSYNC_PROTECT=${RSYNC_PROTECT:-}
RSYNC_INCLUDE=${RSYNC_INCLUDE:-}

declare rsync_args=('--exclude=.git')
declare protect_arg_str='--filter="P .git"'

# Build all rsync filtering arguments in proper order
build_rsync_args() {
  local -A included_dirs=()
  local -a traversal_rules=()
  local -a content_rules=()
  local -a exclude_rules=()
  
  # Process includes first to generate traversal and content rules
  if [[ -n "$RSYNC_INCLUDE" ]]; then
    IFS=',' read -ra INCLUDES <<< "$RSYNC_INCLUDE"
    for include in "${INCLUDES[@]}"; do
      [[ -n "$include" ]] || continue
      
      # Strip trailing slashes for consistent processing
      include="${include%/}"
      
      # Generate include rules for each path component to allow directory traversal
      local path_components=()
      local current_path=""
      
      # Split path into components
      IFS='/' read -ra path_parts <<< "$include"
      for part in "${path_parts[@]}"; do
        [[ -n "$part" ]] || continue
        if [[ -n "$current_path" ]]; then
          current_path="$current_path/$part"
        else
          current_path="$part"
        fi
        path_components+=("$current_path")
      done
      
      # Add include rules for directory traversal (all path components except the last)
      for ((i=0; i<${#path_components[@]}-1; i++)); do
        local dir_path="${path_components[i]}"
        if [[ -z "${included_dirs[$dir_path]:-}" ]]; then
          traversal_rules+=("--include=$dir_path/")
          included_dirs[$dir_path]=1
        fi
      done
      
      # Add include rule for the final path (include all contents with /***)
      if [[ ${#path_components[@]} -gt 0 ]]; then
        local final_path="${path_components[-1]}"
        content_rules+=("--include=$final_path/***")
      fi
    done
  fi
  
  # Process excludes
  if [[ -n "$RSYNC_EXCLUDE" ]]; then
    IFS=',' read -ra EXCLUDES <<< "$RSYNC_EXCLUDE"
    for exclude in "${EXCLUDES[@]}"; do
      [[ -n "$exclude" ]] && exclude_rules+=("--exclude=$exclude")
    done
  fi
  
  # Build final args array in correct order:
  # 1. Start with base exclusions
  rsync_args=('--exclude=.git')
  
  # 2. Add directory traversal includes
  rsync_args+=("${traversal_rules[@]}")
  
  # 3. Add excludes (these need to come before content includes for proper precedence)
  rsync_args+=("${exclude_rules[@]}")
  
  # 4. Add content includes
  rsync_args+=("${content_rules[@]}")
  
  # 5. Add final exclude-all rule when includes are specified
  if [[ ${#content_rules[@]} -gt 0 ]]; then
    rsync_args+=("--exclude=*")
  fi
}

# Build protection argument string
build_protect_args() {
  # Always protect the git-livereload info file
  protect_arg_str+=" --filter=\"P .git-livereload-info\""
  
  if [[ -n "$RSYNC_PROTECT" ]]; then
    IFS=',' read -ra PROTECTS <<< "$RSYNC_PROTECT"
    for protect in "${PROTECTS[@]}"; do
      if [[ -n "$protect" ]]; then
        protect_arg_str+=" --filter=\"P $protect\""
      fi
    done
  fi
}

# Function to handle syncing for a given repository
handle_sync() {
  local repo_name="$1"
  local src_dir="/repos/mount/$repo_name"
  local work_dir="/repos/serve/$repo_name"

  # Execute the rsync command with specific info level
  # Convert array to space-separated string for eval
  local rsync_args_str="${rsync_args[*]}"
  eval "rsync -a --delete --info=flist0,name $rsync_args_str $protect_arg_str $src_dir/ $work_dir/"
  
  # Ensure there's always at least one file present
  ensure_info_file "$work_dir"
}

# Function to ensure an info file is always present
ensure_info_file() {
  local work_dir="$1"
  local info_file="$work_dir/.git-livereload-info"
  
  # Create info file with current status
  cat > "$info_file" << EOF
# Git LiveReload Status

This file is automatically generated by git-livereload to ensure there's always
at least one file present in the repository, even when no source files are
available or match the current filtering rules.

Repository: $(basename "$work_dir")
Last updated: $(date -I)
Process ID: $$

## Filtering Configuration
EOF
  
  # Add rsync configuration details and file count information
  local file_count
  file_count=$(find "$work_dir" -type f ! -name ".git-livereload-info" ! -path "*/.git/*" | wc -l)
  
  {
    if [[ -n "$RSYNC_INCLUDE" ]]; then
      echo "Include patterns: $RSYNC_INCLUDE"
    fi
    
    if [[ -n "$RSYNC_EXCLUDE" ]]; then
      echo "Exclude patterns: $RSYNC_EXCLUDE"
    fi
    
    if [[ -n "$RSYNC_PROTECT" ]]; then
      echo "Protected patterns: $RSYNC_PROTECT"
    fi
    
    echo "Source files synced: $file_count"
    echo ""
    echo "For more information about git-livereload, visit:"
    echo "https://github.com/windsorcli/git-livereload"
  } >> "$info_file"
}

# Perform Git operations in a separate function for clarity
handle_git_operations() {
  local work_dir="$1"
  cd "$work_dir" || return

  git add .

  if ! git diff --quiet --cached; then
    local timestamp
    timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    git commit -m "Autocommit: $timestamp"
    git pull --rebase origin main
    git push origin main
    
    # Show commit SHA of last push
    local commit_sha
    commit_sha=$(git rev-parse HEAD)
    echo "INFO: Last commit pushed: $commit_sha"

    # Send webhook if URL is set
    if [[ -n "$WEBHOOK_URL" ]]; then
      local curl_opts="-X POST -H 'Content-Type: application/json' -s -d '{\"event\":\"commit_pushed\",\"timestamp\":\"$timestamp\"}'"
      if [[ "$VERIFY_SSL" == "false" ]]; then
        curl_opts="-k $curl_opts"
      fi
      eval "curl $curl_opts \"$WEBHOOK_URL\""
      echo "Webhook sent"
    fi
  fi
}

# Initialize repository if it doesn't exist
initialize_repository() {
  local repo_name="$1"
  local source_dir="$2"
  
  if [ ! -d "/repos/git/$repo_name.git" ] || [ ! -d "/repos/serve/$repo_name" ]; then
    echo "Initializing new repository: $repo_name"
    
    # Clean out existing directories
    rm -rf "/repos/git/$repo_name.git" "/repos/serve/$repo_name"

    # Initialize bare and non-bare repositories
    git init --bare "/repos/git/$repo_name.git"
    mkdir -p "/repos/serve/$repo_name"
    cd "/repos/serve/$repo_name" || return
    git config --global --add safe.directory "/repos/serve/$repo_name"
    git init
    git remote add origin "file:///repos/git/$repo_name.git"

    # Sync files and make initial commit
    rsync -av "${rsync_args[@]}" "$source_dir/" .
    
    # Ensure info file is present from the start
    ensure_info_file "$(pwd)"
    
    git add .
    git commit -m 'Initial commit'
    git branch -m main
    git push -u origin main
    
    echo "Repository $repo_name initialized successfully"
  fi
}

# Main execution
build_rsync_args
build_protect_args

while true; do
  # Check if mount directory exists and has content
  if [ -d "/repos/mount" ] && [ -n "$(ls -A /repos/mount 2>/dev/null)" ]; then
    for dir in /repos/mount/*; do
      if [ -d "$dir" ]; then
        repo_name=$(basename "$dir")
        
        # Initialize repository if needed (handles new repositories dynamically)
        initialize_repository "$repo_name" "$dir"
        
        handle_sync "$repo_name"
        handle_git_operations "/repos/serve/$repo_name"
      fi
    done
  else
    echo "No repositories found in /repos/mount, waiting..."
  fi
  sleep 1
done
